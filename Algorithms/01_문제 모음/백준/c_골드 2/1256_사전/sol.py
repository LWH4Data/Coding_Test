import sys, time
sys.stdin = open("input.txt")
s_t = time.time()

#======================================================================
N, M, K = map(int, input().split())
# 조합의 경우의 수를 저장하는 DP 테이블
#   ● 핵심 조합이 C(N + M, M) 또는 C(N + M, N)이며 N + M = 200이기에 202로 설정한다.
#   ● N + M 중 N 혹은 M을 뽑는 조합인 이유는 a 혹은 z로 이루어져 N 개를 추출하면 알아서
#     나머지가 결정되기 때문이다.
D = [[0] * 202 for _ in range(202)]

# 조합 테이블 값 업대이트
for i in range(0, 201):
    # 선택하는 수의 개수(j)가 전체 수의 개수(i - 1)을 넘을 수 없음.
    for j in range(0, i + 1):
        # 1개를 뽑거나 0개를 뽑는 경우 1로 초기화
        #   ● 기존의 j == 1인 경우 i로 할당되는 경우는 하단의 점화식에 포함되기에 생략한다.
        if j == 0 or j == i:
            D[i][j] = 1
        # 위에 해당하지 않는다면 연산으로 값 초기화
        else:
            D[i][j] = D[i - 1][j - 1] + D[i - 1][j]
            # K 범위를 넘어간다면 범위의 최댓값 저장.
            #   ● 쓸대없는 값을 제거하여 최적화 한다.
            if D[i][j] > 1000000000:
                D[i][j] = 1000000001

# 주어진 자릿수로 만들 수 없는 K 번째 수의 경우 -1을 출력.
if D[N + M][M] < K:
    print(-1)
# 출력이 가능한 경우
else:
    while not (N == 0 and M == 0):
        # a를 선택해도 남은 경우의 수가 K보다 큰 경우 a를 출력
        #   ● K는 a로 시작하는 그룹에 속하기에 a를 출력한다.
        if D[N - 1 + M][M] >= K:
            print("a", end='')
            N -= 1
        # 아닌 경우 b를 출력하고, K와 M을 업데이트
        #   ● 남은 경우의 수가 K보다 작다는 건 a로 시작하는 조합의 수보다 K가 큰 것이기에 K는
        #     z로 시작하는 그룹에 속하게 되기 때문이다.
        else:
            print("z", end='')
            # 건너 뛴 그룹의 크기만큼 K를 줄인다.
            K -= D[N - 1 + M][M]
            M -= 1
#======================================================================

e_t = time.time()
print("time: ", e_t - s_t)