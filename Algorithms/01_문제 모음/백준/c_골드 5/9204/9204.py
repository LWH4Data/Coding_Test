import sys, time
sys.stdin = open('input_9204.txt')
start_time = time.time()

#==========================================================
from collections import deque

# 이동 델타
# 일단 최대 7칸 움직일 수 있읜까 7칸으로 구현하고, idx 넘어가면 예외처리하는 걸로
dv = (-1, -2, -3, -4, -5, -6, -7, # 좌상
      -1, -2, -3, -4, -5, -6, -7, # 우상
      1, 2, 3, 4, 5, 6, 7, # 좌하
      1, 2, 3, 4, 5, 6, 7) # 우하
dh = (-1, -2, -3, -4, -5, -6, -7,
      1, 2, 3, 4, 5, 6, 7,
      -1, -2, -3, -4, -5, -6, -7,
      1, 2, 3, 4, 5, 6, 7)

T = int(input())

for tc in range(1, 1 + T):
    s_h, s_v, e_h, e_v = input().split()

    # x 축을 위한 인접리스트 생성.
    # index() 모듈을 통해 받아올 것임.
    hori = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

    # 탐색을 위한 graph 생성
    # 그냥 visited 처럼 사용하면 될 듯?
    graph = [[False] * 8 for _ in range(8)]
    
    # 시작점 변환해서 받기
    s_h = hori.index(s_h)
    e_h = hori.index(e_h)

    # 일단 끝점은 queue에 넣어야 하니가 변경해야 함.
    start = deque()
    start.append((s_v, s_h)) # 수직, 수평

    ans = BFS()

    # 위치를 업데이트 하면서








    # 정답 출력시 idx + 1


#==========================================================

end_time = time.time()
print('time :', end_time - start_time)


'''
< 로직 1 >
1. 자료 구조를 어떻게 할지?
    - 그냥 9*9 이차원 배열을 만들고 (근데 BFS 탐색 때문에 8 * 8로 구현하고, 나중에 + 1하는 게 나을지도?)
    -> 가로변에 해당하는 인접 리스트를 생성해서
    -> 관리?

2. 대각 이동 델타를 만들면된다.
    - 문제는 대각으로 한 칸 이동이 아니라 탐색 범위 내에 해당하는 모든 영역을 탐색한다.
'''

'''
< 시간 복잡도 >
1. 전체 판의 크기가 결국 8 * 8이고 그중에서도 비숍 탐색하는 범위는 더 적다.

2. 탐색의 depth 또한 4이기에 시간 복잡도가 넘칠 일은 없다.
'''

'''
< 문제 정리 >
1. 비숍은 대각선으로만 이동.
    - 한 번에 갈 수 있는 경우와 
    - 한 번에 갈 수 없다면 다른 곳으로 이동하고 다시 이동.
    - 최대 네 번 움직임.
        -> depth가 4라는 의미.
        -> 찬영이가 사용한 방법을 하면 되나?

2. 두 좌표가 주어짐
    - 시작 위치

3. 출력
    - 움지인 횟수, 비숍이 멈춤 지점(즉, 정지점)
'''